# IO_Flush

### Запуск
Для запуска эксперимента достаточно запустить скрипт run_experiment.sh
```
bash ./run_experiment.sh
```

Также можно отдельно собрать утилиту для запуска эксперимента с помощью make
```
make
```

И далее можно будет запустить утилиту с помощью команды
```
./build/experiment
```

### Эксперимент
Был проведен следующий эксперимент:
1. Последовательно выведено 3 строки STDOUT в stdout
2. Последовательно выведено 3 строки STDERR в stderr

Были испробованы 3 варианта выводить строки:
1. Без flush-а
2. C flush-ем после каждого вызова puts в соответсвующий поток вывода
3. C flush-ем после всех вызовов puts в соответсвующий поток вывода

Кроме того, строки могли заканчиваться, а могли не заканчиваться символом \n.

##### Операционная система
Эксперимент проводился на WSL с дистрибутивом Ubuntu
```
$ uname -a
Linux HOME-PC 5.10.16.3-microsoft-standard-WSL2 #1 SMP Fri Apr 2 22:23:49 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux
```

##### Результат
Получились следующие результаты:
1. Разницы между flush-ем после каждого вызова puts и после всех вызовов puts в соответсвующий поток вывода нет, что ожидаемо

2. В случае отказа от flush и вывода в терминал строк без символа \n получилось так, что stderr был отображен первее, чем stdout. В остальных случаях при выводе на терминал был правильный порядок: сначала отображался stdout, потом stderr.

Вывод в терминал без flush и \n.
```
STDERR STDERR STDERR STDOUT STDOUT STDOUT
```
3. В случае вывода в файл без flush-а, вне зависимости от символа \n впервее отображался stderr. В остальных случаях при выводе в файл был правильный порядок: сначала отображался stdout, потом stderr.

Вывод в файл без flush и без \n.
```
STDERR STDERR STDERR STDOUT STDOUT STDOUT
```

Вывод в файл без flush, но с \n.
```
STDERR
STDERR
STDERR
STDOUT
STDOUT
STDOUT
```